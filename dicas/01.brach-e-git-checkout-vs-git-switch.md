# Criando Branch e Aprendendo a Diferen√ßa entre 'Git Switch' vs. 'Git Checkout': Qual Comando Devemos Usar?

Por muitos anos, o comando `git checkout` foi a ferramenta "faz-tudo" do Git, respons√°vel por mudar de ***branch***, restaurar arquivos e at√© mesmo criar novos ***branches***. No entanto, essa sobrecarga de responsabilidades tornava o comando confuso, especialmente para iniciantes.

Para resolver essa ambiguidade, o Git introduziu dois novos comandos a partir da **vers√£o 2.23**: `git switch` e `git restore`. O objetivo foi separar a preocupa√ß√£o de "navega√ß√£o" da preocupa√ß√£o de "restaura√ß√£o".

---

## 1. Entendendo o `git checkout` (O Comando Antigo)

O `git checkout` √© um comando polivalente que pode realizar tr√™s a√ß√µes principais:

| Uso | Objetivo | Exemplo |
| :--- | :--- | :--- |
| **Mudar de Branch** | Alternar entre ***branches*** ou criar um novo. | `git checkout nome-da-branch` |
| **Restaurar Arquivos** | Descartar mudan√ßas n√£o confirmadas em um arquivo, restaurando-o para a vers√£o do √∫ltimo ***commit***. | `git checkout -- arquivo.txt` |
| **Voltar a um Commit** | Mudar para um estado de ***commit*** espec√≠fico, entrando no estado **"HEAD desanexado"** (*Detached HEAD*). | `git checkout 9a3b8c2` |

**O Problema:** A sintaxe para mudar de ***branch*** (`git checkout nome-da-branch`) era muito parecida com a sintaxe para restaurar um arquivo (`git checkout -- arquivo.txt`), levando a erros e confus√£o.

---

## 2. Apresentando `git switch` (O Comando Novo e Recomendado)

O `git switch` foi introduzido com um prop√≥sito √∫nico e claro: **Mudar de *branch***. Ele retira essa responsabilidade do `git checkout`, tornando a navega√ß√£o mais segura e leg√≠vel.

### Principais Casos de Uso do `git switch`:

| A√ß√£o | Comando com `git switch` | Coment√°rios |
| :--- | :--- | :--- |
| **Mudar para um *branch* existente** | `git switch nome-da-branch` | Simples e claro. |
| **Criar e Mudar para um novo *branch*** | `git switch -c novo-branch` | O ***flag*** `-c` (*create*) √© a forma padr√£o. |
| **Criar um novo *branch* baseado em um *commit*** | `git switch -c novo-branch 9a3b8c2` | Cria o ***branch*** a partir de um ***commit*** espec√≠fico. |

---

## 3. Qual Comando Devo Usar?

**Recomenda√ß√£o:** Use **`git switch`** para todas as opera√ß√µes de mudan√ßa de ***branch*** e **`git restore`** para todas as opera√ß√µes de restaura√ß√£o de arquivos.

### Por que Mudar?

1.  **Clareza e Legibilidade:** Se voc√™ v√™ `git switch`, sabe instantaneamente que a inten√ß√£o √© **mudar de contexto** (trocar de ***branch***).
2.  **Separa√ß√£o de Preocupa√ß√µes:** O Git agora tem comandos espec√≠ficos para cada tarefa:
    * **`git switch`**: Para **navega√ß√£o** entre ***branches***.
    * **`git restore`**: Para **restaura√ß√£o** de arquivos (desfazer mudan√ßas).
    * **`git checkout`**: Permanece para casos de **"HEAD desanexado"** ou para comandos legados.
3.  **Seguran√ßa para Iniciantes:** O `git switch` possui verifica√ß√µes internas mais rigorosas. Por exemplo, ele se recusa a alternar ***branches*** se o seu diret√≥rio de trabalho estiver em um estado que seria destrutivo, a menos que voc√™ use um ***flag*** de for√ßa.

### Tabela de Equival√™ncia e Substitui√ß√£o

| Objetivo | Comando Antigo (`checkout`) | Comando Recomendado (Moderno) |
| :--- | :--- | :--- |
| **Mudar para `dev`** | `git checkout dev` | **`git switch dev`** |
| **Criar e Mudar para `feature`** | `git checkout -b feature` | **`git switch -c feature`** |
| **Desfazer mudan√ßas no `README.md`** | `git checkout -- README.md` | **`git restore README.md`** |
| **Restaurar arquivo do *staging* para o WD** | `git checkout -- arquivo.txt` | **`git restore arquivo.txt`** |

---

## 4. Melhores Pr√°ticas

1.  **Adote `git switch` Imediatamente:** Se voc√™ usa uma vers√£o do Git mais recente que a **2.23**, comece a usar `git switch` e `git restore`. √â a dire√ß√£o futura do Git.
2.  **Evite o "HEAD desanexado" (*Detached HEAD*):** Mudar para um ***commit*** espec√≠fico (e n√£o um ***branch***) usando `git checkout <commit-sha>` coloca voc√™ em um estado onde seus novos ***commits*** n√£o pertencem a nenhuma ***branch***. Se voc√™ precisar inspecionar um ***commit*** antigo, use:
    * **`git switch --detach <commit-sha>`**: Faz o mesmo que o `checkout` para esse prop√≥sito, mas deixa claro que voc√™ est√° **desanexando** o HEAD.
3.  **Use o `git restore` para Limpeza:** Se voc√™ cometer um erro localmente e quiser descartar todas as altera√ß√µes n√£o ***staged*** em um arquivo, o comando `git restore nome-do-arquivo` √© a maneira limpa e intencional de faz√™-lo.

---

## Exemplos de Uso no Fluxo de Trabalho (*Flow*)

Vamos simular o fluxo de trabalho de um desenvolvedor: criar uma ***branch*** de funcionalidade, fazer altera√ß√µes, ***comitar***, voltar para a principal (`main`) e, finalmente, integrar o trabalho.

### Cen√°rio: Adicionar uma Nova Funcionalidade (*Feature*)

### Passo A: Cria√ß√£o e Mudan√ßa de Branch

O desenvolvedor precisa sair da ***branch*** principal (`main`) para trabalhar na nova funcionalidade (`feature/login`).

| Objetivo | Comando Recomendado (`git switch`) | Comando Legado (`git checkout`) |
| :--- | :--- | :--- |
| **Criar e Mudar** para a nova ***branch*** | **`git switch -c feature/login`** | `git checkout -b feature/login` |

**Explica√ß√£o:** O `switch -c` (de *create*) √© direto e deixa claro que voc√™ est√° **mudando o contexto** de trabalho.

### Passo B: Edi√ß√£o e Commit

1.  O desenvolvedor edita um arquivo, digamos `auth.js`.
2.  Antes de ***comitar***, percebe que fez uma mudan√ßa errada e quer **descartar** apenas as mudan√ßas locais, restaurando o arquivo para o estado do √∫ltimo ***commit***.

| Objetivo | Comando Recomendado (`git restore`) | Comando Legado (`git checkout`) |
| :--- | :--- | :--- |
| **Descartar Mudan√ßas** no arquivo `auth.js` | **`git restore auth.js`** | `git checkout -- auth.js` |

**Explica√ß√£o:** O `git restore` isola a funcionalidade de "desfazer", evitando a confus√£o do comando `checkout`.

3.  Ap√≥s corrigir e salvar, o desenvolvedor adiciona e ***comita*** a altera√ß√£o:

    ```bash
    git add auth.js
    git commit -m "feat: Implementa l√≥gica inicial de login"
    ```

### Passo C: Voltando para a Branch Principal

O trabalho est√° pronto. O desenvolvedor precisa voltar para a ***branch*** principal (`main`) para integr√°-lo.

| Objetivo | Comando Recomendado (`git switch`) | Comando Legado (`git checkout`) |
| :--- | :--- | :--- |
| **Mudar de Volta** para a `main` | **`git switch main`** | `git checkout main` |

**Explica√ß√£o:** Novamente, `git switch` √© usado para **navegar** para o ***branch*** de destino.

### Passo D: Integrando as Altera√ß√µes (*Merging*)

Com o desenvolvedor na ***branch*** `main`, √© hora de trazer o c√≥digo da `feature/login`.

```bash
# Estando na branch 'main', integre as mudan√ßas
git merge feature/login

# Se o merge for bem-sucedido, a branch de feature pode ser exclu√≠da
git branch -d feature/login
```

-----

## 3\. Resumo da Recomenda√ß√£o e Melhores Pr√°ticas

| O Que Fazer | Comando Recomendado | Por que Usar? |
| :--- | :--- | :--- |
| **Mudar de Branch** | `git switch <branch-name>` | Clareza. Inten√ß√£o direta de **navegar**. |
| **Criar Branch** | `git switch -c <new-branch-name>` | Padr√£o mais limpo para **cria√ß√£o**. |
| **Desfazer/Restaurar Arquivos** | `git restore <file-name>` | Separa√ß√£o de responsabilidades. |
| **Voltar no Tempo (HEAD desanexado)** | `git checkout <commit-sha>` | **√önico caso** onde `checkout` ainda √© o mais comum, mas com a ressalva de entrar no estado "Detached HEAD". |

**Conclus√£o:** O comando **`git switch`** √© a melhor pr√°tica atual para **gerenciar e navegar entre *branches***, e sua ado√ß√£o torna o fluxo de trabalho Git mais intuitivo e menos propenso a erros.

-----
## Extra

### Qual Nome Usar para a Branch Principal? (main vs. master)

#### üîπ Antes (padr√£o hist√≥rico)
- **`master`** era o nome padr√£o criado automaticamente pelo Git at√© meados de 2020.  
- Era considerado o *mainline*, mas acabou sendo substitu√≠do por raz√µes culturais e de clareza.

---

#### üîπ Hoje (padr√£o do mercado)
- **`main`** √© o nome mais **profissional e usado mundialmente** hoje.  
- GitHub, GitLab, Bitbucket e outros provedores modernos **j√° criam reposit√≥rios novos com `main`** por padr√£o.  
- √â amplamente adotado em projetos open-source, empresas e documenta√ß√£o oficial.  

---

#### üîπ Por que `main` √© melhor?
- **Clareza:** transmite que √© a ‚Äúbranch principal‚Äù sem ambiguidade.  
- **Consist√™ncia:** todos os servi√ßos e comunidades j√° migraram.  
- **Compatibilidade:** pipelines, CI/CD e ferramentas modernas j√° esperam `main`.  

---

#### üîπ Exce√ß√µes
- Projetos **legados** ainda podem usar `master`, especialmente se t√™m pipelines antigos atrelados a esse nome.  
- Algumas equipes optam por nomes diferentes (ex.: `develop`, `production`, `release`) em fluxos mais complexos (Git Flow, Trunk-based, etc.), mas **o ponto de refer√™ncia quase sempre √© `main`**.

---

#### ‚úÖ Resposta curta
O mais profissional e padr√£o do mercado **hoje** √© usar **`main`** como branch principal.

