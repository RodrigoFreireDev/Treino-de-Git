![Exemplo Worktree](../img/git-worktree-banner.png)
# Git Worktree: Criando múltiplos diretórios de trabalho para branches diferentes

## Objetivo
Permitir trabalhar em múltiplas branches ao mesmo tempo sem precisar fazer `stash` ou `checkout` no diretório principal do projeto.

---

## O que é um worktree
- Uma **worktree** é uma cópia independente de uma branch do mesmo repositório Git.
- Compartilha o histórico e os objetos do repositório principal, mas tem seu próprio diretório de trabalho e índice (staging area).
- Economiza espaço em disco em comparação a múltiplos clones.

---

## Criando um Worktree

![Imagem exemplo simple e visual worktree](../img/git-worktree-1.png)

### Passo 1: Criar um novo diretório de trabalho para a branch
```sh
git worktree add <caminho_do_novo_diretorio> <branch_existente>
````

**Exemplo:**

```sh
git worktree add ../hotfix main
```

* Cria o diretório `../hotfix` e faz checkout da branch `main` nele.
* Se quiser criar uma branch nova na worktree:

```sh
git worktree add -b <nome_da_nova_branch> <caminho> <branch_base>
```

Exemplo:

```sh
git worktree add -b hotfix/bug-123 ../hotfix main
```

---

### Passo 2: Navegar para o worktree

```sh
cd ../hotfix
```

* Aqui você pode editar arquivos, criar commits e fazer push normalmente.
* As alterações neste diretório não afetam a worktree principal.

---

### Passo 3: Listar worktrees existentes

```sh
git worktree list
```

**Saída exemplo:**

```
~/meu-projeto 5b67eb2 [main]
~/meu-projeto-hotfix 2ff5902 [hotfix-123]
```

---

### Passo 4: Remover um worktree

* Quando terminar de trabalhar em um worktree:

```sh
git worktree remove <caminho>
```
---
#### Exemplo de como fica a extrutura com e sem o worktree

**Estrutura do Diretório**:

/projeto-sem-worktree  
├── .git/               \<- Repositório Git principal  
├── index.html  
├── src/  
│   ├── app.js  
│   └── styles.css  
├── .gitignore  
└── README.md

**Estrutura do Diretório**:

/caminho/do/seu/projeto/  
├── projeto-com-worktree/       \<- \*\*Worktree Principal\*\* (ex: no branch: feature/novo-recurso)  
│   ├── .git/                   \<- Repositório Git real (compartilhado)  
│   ├── index.html  
│   └── src/  
│       ├── app.js              \<- Com alterações em andamento (não commitadas)  
│       └── ...  
└── hotfix-critico/             \<- \*\*Worktree Vinculado\*\* (no branch: hotfix/bug-critico)  
    ├── .git                    \<- É um arquivo que aponta para o .git principal  
    ├── index.html  
    └── src/  
        ├── app.js              \<- Com a correção aplicada e commitada  
        └── ...

![Imagem exemplo simple e visual worktree](../img/git-worktree-2.png)

---

## Fluxo prático

1. Criar worktree para correção urgente:

```sh
git worktree add -b hotfix/bug-ABC ../hotfix main
```

2. Navegar para a worktree:

```sh
cd ../hotfix
```

3. Fazer alterações, commit e push:

```sh
git add .
git commit -m "Hotfix: Corrigido bug ABC"
git push origin hotfix/bug-ABC
```

4. Voltar para o diretório principal:

```sh
cd ../projeto-com-worktree
```

5. Absorver correção:

```sh
git merge hotfix/bug-ABC
git push origin main
```

6. Remover worktree e branch temporária:

```sh
git worktree remove ../hotfix
git branch -d hotfix/bug-ABC
```

#### Exemplo grafico:
```mermaid
graph  TD

%% Fluxo Principal (Worktree)

subgraph  Worktree["Criacao  e  Trabalho  no  Worktree"]

A[Inicio: Trabalhando  em  feature/X] --> W1

W1(git worktree add ../hotfix -b hotfix/bug-ABC main)  --> W2

W2(cd ../hotfix)  --> W3{Aplicar  correcao  de  bug}

W3  --> W4(git add .)

W4  --> W5(git commit -m 'Hotfix: Correcao do Bug ABC')

W5  --> W6(git push origin hotfix/bug-ABC)

end

  

%% Fluxo de Integracao (Main)

subgraph  Main["Integracao  e  Finalizacao"]

W6  --> I1{Revisao  de  Codigo  PR  Aprovada}

I1  --  Sim  --> I2(Voltar ao Diretorio Principal: cd ../seu-projeto)

I2  --> I3(git switch main)

I3  --> I4(Absorver correcao: git merge hotfix/bug-ABC)

I4  --> I5(git push origin main)

I5  --> I6(git worktree remove ../hotfix)

I6  --> I7(Limpar o branch: git branch -d hotfix/bug-ABC)

I7  --> F[Fim: Bug  corrigido  e  worktree  finalizado]

  

%% Reverte ao push para mais trabalho ou revisao

I1  --  Nao  --> W6

end

  

%% Fluxo de Retorno ao Feature

subgraph  Retorno["Continuar  o  Desenvolvimento"]

I7  --> R1(git switch feature/X)

R1  --> R2[Continuar  o  trabalho  em  feature/X]

end
```
---
## Vantagens do uso de worktrees

* **Trabalho simultâneo:** Correções rápidas ou testes sem interromper o desenvolvimento principal.
* **Isolamento:** Cada worktree possui seu próprio diretório de trabalho e staging.
* **Economia de espaço:** Não é necessário clonar o repositório inteiro para cada branch.
* **Fluxo de trabalho contínuo:** Não precisa usar `stash` para alternar entre branches.

---

## Conclusão

O `git worktree` é extremamente útil para:

* Corrigir bugs críticos sem interromper o desenvolvimento atual.
* Testar branches de colegas de equipe.
* Comparar múltiplas versões simultaneamente.
* Evitar uso excessivo de `stash` ou commits WIP.

