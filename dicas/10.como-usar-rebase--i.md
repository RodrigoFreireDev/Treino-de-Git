# Como fazer um Interactive rebase(git rebase -i)

O git rebase -i (rebase interativo) é uma ferramenta poderosa para reescrever o histórico de commits de uma branch antes de mesclá-la no ramo principal. O principal objetivo é organizar um histórico "bagunçado" (cheio de pequenos commits incrementais) em uma sequência limpa e significativa.

## Cuidado importante

Nunca use rebase interativo em uma branch que você já publicou e está sendo usada por outras pessoas, pois reescreve o histórico. Use-o apenas em branches locais para que seu histórico seja limpo antes do push final.

### Passo a passo para o rebase interativo

- Suponha que você tenha alguns commits em uma branch de recurso e queira combiná-los (squash) e renomear (reword) a mensagem antes de publicá-los.

1. Inicie o rebase interativo

- Escolha o ponto no histórico a partir do qual você deseja reescrever. O comando mais comum é HEAD~n, onde n é o número de commits que você quer editar, contando a partir do mais recente.

    ```sh
        # Exemplo para os últimos 3 commits
        git rebase -i HEAD~3

- Isso abrirá um editor de texto com uma lista dos commits que você selecionou.

2. Edite o arquivo de rebase

- O arquivo que se abrirá listará os commits de baixo para cima (do mais antigo para o mais recente). As instruções de uso estarão no mesmo arquivo, junto com os comandos que você pode usar:

    ```
        pick 5938f9b Adiciona feature A
        pick 12e5c7a Corrige typo na feature A
        pick 8d09a2f Atualiza feature A

        # Rebase 5938f9b..8d09a2f onto 5938f9b (3 commits)
        #
        # Comandos:
        # p, pick <commit> = usar o commit
        # r, reword <commit> = usar o commit, mas editar a mensagem
        # e, edit <commit> = usar o commit, mas parar para alterar os arquivos
        # s, squash <commit> = usar o commit, mas combiná-lo com o commit anterior
        # f, fixup <commit> = como squash, mas descarta a mensagem do commit
        # x, exec <comando> = executar um comando shell
        # d, drop <commit> = remover o commit
        # l, label <label> = marcar o commit atual
        # t, reset <label> = redefinir o HEAD para o label
        # m, merge [-C <commit>|-c <commit>] <label> = mesclar o commit atual no label

3. Realize as ações (squash, reword)

3.1 Squash (Combinar commits): Para combinar os três commits em um único, você deve alterar as linhas dos commits mais recentes para squash (ou s).

    ```
        pick 5938f9b Adiciona feature A
        s 12e5c7a Corrige typo na feature A
        s 8d09a2f Atualiza feature A

3.2 Reword (Renomear a mensagem): Para editar a mensagem de um commit, altere a linha para reword (ou r).

    ```
        r 5938f9b Adiciona feature A
        s 12e5c7a Corrige typo na feature A
        s 8d09a2f Atualiza feature A

4. Finalize o rebase

4.1 Depois de salvar e fechar o editor, o Git iniciará o rebase
4.2 Se você usou squash, o Git abrirá outro editor para que você escreva a nova mensagem de commit para o commit combinado.
4.3 Se usou reword, o Git abrirá um editor para cada commit marcado, permitindo que você altere a mensagem.
4.4 Salve e feche cada editor para continuar até o fim do rebase.

5. Envie as mudanças (git push)

- Como o rebase interativo reescreve o histórico, você precisará forçar o push para atualizar o repositório remoto. Se você for o único a usar essa branch, use o comando --force-with-lease para um empurrão mais seguro.

    `sh
        2 git push origin sua-branch --force-with-lease `

### Quando usar o rebase interativo?

* Organizar um histórico de commits local: Transformar vários commits pequenos (ex: "conserta erro", "adiciona arquivo", "corrige typo") em um commit único e significativo (ex: "Implementa funcionalidade de login").

* Limpar branches de recurso: Antes de fazer um pull request, use o rebase interativo para criar um histórico limpo e compreensível, que é mais fácil para os revisores entenderem.

* Evitar commits de mesclagem (merge): Mantenha um histórico linear, que pode ser mais fácil de seguir para alguns projetos.

