# Como criar tags de versão marcando um commit com git tag v1.0?

Para criar uma tag de versão no Git, você pode usar o comando git tag. Existem dois tipos principais de tags: leve (lightweight) e anotada (annotated). É recomendado o uso de tags anotadas para marcações de versão, pois elas armazenam mais metadados, como autor, e-mail, data e uma mensagem descritiva.

Aqui estão os passos para marcar um commit com a tag v1.0.

1. Criar uma tag no commit mais recente:
    - Se você deseja marcar o commit atual (o mais recente), use o seguinte comando:

    ```sh
    git tag -a v1.0 -m "Versão 1.0 lançada"
    ```
    - -a: Cria uma tag anotada.
    - v1.0: É o nome da tag de versão.
    - -m: Adiciona uma mensagem à tag.

2. Criar uma tag em um commit anterior:

    - Se você precisa marcar um commit mais antigo na história, siga estes passos:

    2.1. Encontre o hash do commit:
    ```sh
    git log --oneline'
    ```

    2.2. Crie a tag com o hash:

    - Use o hash do commit no final do comando.

    ```sh
    git tag -a v1.0 [hash-do-commit] -m "Versão 1.0 lançada"
    ```

3. Visualizar as tags:

    - Para listar as tags criadas localmente, use:

    ```sh
    git tag
    ```

    - Para ver mais detalhes sobre uma tag específica, use:

    ```sh
    git show v1.0
    ```

4. Enviar a tag para o repositório remoto:

    - Por padrão, o comando git push não envia as tags para o servidor remoto. Você deve enviá-las explicitamente. 

    4.1. Para enviar uma tag específica:

    ```sh
    git push origin v1.0
    ```

    4.2. git push origin v1.0:

    ```sh
    git push origin --tags
    ```

#### Diferença entre tags anotadas e leves

	Tag Anotada (-a)
	    Tipo: Objeto completo no banco de dados Git.	
	    Metadados: Armazena nome, e-mail, data e mensagem.	
	    Uso: Marcadores permanentes para versões públicas.	
	    Criação: git tag -a <tagname> -m "mensagem"	

	Tag Leve (lightweight)
	    Tipo: Apenas um ponteiro para um commit.
	    Metadados: Não armazena metadados adicionais.
	    Uso: Marcadores temporários ou privados para commits.
	    Criação: git tag <tagname>

-----

# Tags de Versão vs. Releases (Lançamentos): Diferenças e Como Criar

O objetivo é entender que a **Tag de Versão** é um conceito do Git, enquanto o **Release** é um recurso do GitHub que se baseia nessa tag. A diferença fundamental é que a tag marca um ponto no código, e o release empacota essa versão para distribuição ao público.

-----

## Diferença Fundamental entre Tag e Release

**Tags** e **Releases** no Git/GitHub\! Embora estejam intimamente relacionados, eles têm propósitos distintos.

  * **Tag de Versão:** É um recurso **nativo do Git** que marca um ponto específico (um commit) no histórico como um marco importante (ex: `v1.0.0`). É puramente um marcador de código.
  * **Release (Lançamento):** É um recurso **nativo do GitHub/GitLab/Bitbucket** que **empacota** a Tag de Versão. Um *Release* é uma nota de versão, binários anexados, e o código tagueado, tudo junto para ser consumido por usuários finais.

| Característica | Tag de Versão | Release (Lançamento) |
| :--- | :--- | :--- |
| **Origem** | Recurso **nativo do Git** (funciona em qualquer repositório Git). | Recurso **específico do GitHub** (ou GitLab, Bitbucket) que usa uma Tag. |
| **Propósito** | Marcar um ponto significativo no histórico do projeto, como uma versão (`v1.0.0`). | Pacotar e distribuir uma versão do software, com **notas**, **binários** e outros ativos. |
| **Público Alvo** | Desenvolvedores e o sistema de controle de versão. | Usuários finais, testadores, clientes. |
| **Conteúdo** | O código-fonte exato do commit tagueado. | O código tagueado, notas de lançamento detalhadas e ativos binários anexados. |

A diferença é sobre o **público** e o **conteúdo**:

| Recurso | O que é? | Público Alvo | Conteúdo |
| :--- | :--- | :--- | :--- |
| **Tag de Versão** | Um **ponteiro** no histórico do Git. | Desenvolvedores e o sistema de controle de versão. | O código-fonte exato do commit tagueado. |
| **Release** | Um **artefato completo** de software. | Usuários finais, testadores, clientes. | **Tag de Versão**, Notas de Lançamento formatadas, Binários (instaladores ou pacotes) e Código-fonte compactado. |

**Em outras palavras:**

  * Um desenvolvedor usa a **Tag** para saber exatamente qual foi o commit `v1.0.0`.
  * Um usuário final usa o **Release** para baixar o instalador da **Versão 1.0.0** e ler o que há de novo.
-----
Você pode ter uma Tag sem um Release, mas **não pode ter um Release no GitHub sem uma Tag** para ancorá-lo.

## Como Criar uma Tag de Versão

A Tag deve ser criada no commit que você deseja marcar como um marco de versão.

### 1\. No Terminal (Recomendado para o Desenvolvedor)

1.  **Marque o commit com uma Tag Anotada:**
    Tags anotadas (`-a`) são as mais indicadas, pois armazenam metadados importantes (autor, data, mensagem).

    ```bash
    # Garante que você está no branch principal
    git checkout main

    # Cria a tag anotada
    git tag -a v1.0.0 -m "Versão 1.0.0 lançada com o módulo de pagamento."
    ```

2.  **Envie a Tag para o GitHub:**
    As tags não são enviadas por padrão. Envie sua nova tag explicitamente:

    ```bash
    git push origin v1.0.0
    # OU para enviar todas as tags locais:
    git push origin --tags
    ```

### 2\. No Site do GitHub

Você pode criar a Tag na mesma tela de criação do Release:

1.  Navegue até a página do seu repositório.
2.  Clique em **"Releases"** na barra de navegação.
3.  Clique em **"Draft a new release"** (Rascunhar um novo release).
4.  No campo **"Choose a tag"**, digite o nome da tag desejada (ex: `v1.0.0`). O GitHub criará o marcador no commit atual do branch selecionado.

## Como criar um release

### 1\. No site do GitHub

1.  Navegue até a página **Releases** do seu repositório.
2.  Clique em **Create a new release** ou **Draft a new release** (Criar uma nova versão ou Rascunhar um novo release).
3.  **Escolha ou crie uma tag**: No campo **tag**, você pode selecionar uma tag existente ou digitar uma nova para criar.
4.  **Adicione um título e uma descrição**: Insira um título para o release e uma descrição detalhada das mudanças (em Markdown).
5.  **Anexe binários** (opcional): Adicione arquivos compilados, como executáveis ou arquivos compactados, arrastando-os para a caixa de binários.
6.  **Publique o release**: Clique em **Publish release** (Publicar release) para criar o release e torná-lo visível para o público.

## Resumo do fluxo de trabalho
1. Crie uma **tag de versão** no Git, seja via terminal (git tag -a v1.0.0 ...) ou pela interface do GitHub.
2. Envie a tag para o repositório remoto (git push origin v1.0.0).
3. No GitHub, use essa tag para criar um **release**, adicionando notas de lançamento e ativos que os usuários podem baixar.

-----

# Controle de Versões utilizando como base o Versionamento Semântico 2.0.0 (SemVer)

O que vamos ver:

1.  **O que é Versionamento Semântico (SemVer)?**
      * Explicar a estrutura principal: **MAIOR.MENOR.PATCH**.
      * Explicar o significado de cada número.
2.  **Melhores Práticas e Dicas de Uso:**
      * Quando e como incrementar cada parte.
      * Uso de pré-lançamentos (pre-releases).
      * Uso de metadados de compilação (build metadata).
      * Relação com o controle de código-fonte (Git).

## A Estrutura do SemVer(Versionamento Semântico 2.0.0)

O **Versionamento Semântico** (Semantic Versioning ou **SemVer**) é uma especificação simples de regras e requisitos que ditam como os números de versão são atribuídos e incrementados. Seu principal objetivo é comunicar o **significado** de uma mudança no seu código para os usuários (e.g., outros desenvolvedores) por meio do número da versão.

A especificação mais comum e amplamente adotada é a **Versão 2.0.0**.

A estrutura fundamental de uma versão SemVer é composta por **três números** separados por pontos, seguindo o formato:

$$\text{MAIOR.MENOR.PATCH}$$

$$\text{X.Y.Z}$$

| Posição | Nome | O que indica | Quando incrementar |
| :---: | :---: | :---: | :---: |
| **X** | **MAIOR** (Major) | Indica **mudanças incompatíveis** na API (Application Programming Interface). | Quando há alterações que **quebram a compatibilidade** retroativa (breaking changes). |
| **Y** | **MENOR** (Minor) | Indica **novas funcionalidades** que são **compatíveis** retroativamente. | Quando novas funcionalidades são adicionadas de forma compatível, ou grandes melhorias. |
| **Z** | **PATCH** | Indica **correções de bugs** que são **compatíveis** retroativamente. | Quando há correções de bugs pequenas e compatíveis (hotfixes, patches). |

### Exemplo Prático

Se o seu projeto está na versão `1.2.3`:

1.  Se você corrige um bug: vai para `1.2.4`
2.  Se você adiciona uma nova funcionalidade compatível: vai para `1.3.0` (o PATCH é resetado para 0)
3.  Se você faz uma mudança que exige que os usuários alterem seu código (mudança "quebradora"): vai para `2.0.0` (o MENOR e o PATCH são resetados para 0)

-----

## Dicas e Melhores Práticas para Usar SemVer

Para garantir que o Versionamento Semântico seja eficaz e claro em seu projeto, siga estas dicas:

### 1\. Regra de Ouro: Seja Consistente

A maior dica é a **consistência**. Se você decidir que uma correção de segurança é um `PATCH`, trate-a sempre como um `PATCH`.

### 2\. A Fase de Desenvolvimento Inicial (0.Y.Z)

  * **Não use a versão 0.Y.Z em produção:** A versão `0.Y.Z` (e.g., `0.1.0`, `0.2.5`) é considerada a fase de **desenvolvimento inicial**.
  * **Significado Especial:** Durante essa fase, **qualquer coisa pode mudar a qualquer momento**. O número **MENOR** (Y) pode ser incrementado para indicar mudanças que, em teoria, seriam *Major* (quebradoras) em versões futuras.
  * **O Início Real:** O projeto deve atingir **1.0.0** quando for considerado **pronto para produção** e a API estiver estável e definida.

### 3\. Gerenciando "Breaking Changes" (MAIOR)

  * **Comunique-se claramente:** Antes de lançar uma nova versão **MAIOR** (e.g., de `1.5.0` para `2.0.0`), documente e comunique *exatamente* o que quebrou e como os usuários devem migrar (migration guide).
  * **Depreciação:** Se você precisar remover ou alterar drasticamente uma funcionalidade, primeiro **deprecie-a** (marque-a como obsoleta) em uma versão **MENOR** (e.g., em `1.8.0`) e só a remova na próxima versão **MAIOR** (`2.0.0`). Isso dá tempo aos usuários para se adaptarem.

### 4\. Usando Pré-Lançamentos (Pre-releases)

Para testar mudanças antes de um lançamento final, use sufixos de rótulos pré-lançamento (pre-releases) após o número **PATCH**.

  * **Formatos:** Use um hífen (`-`) seguido por identificadores. Exemplo: `1.0.0-alpha`, `1.0.0-beta.2`, `1.0.0-rc.1`.
  * **Ordem:** As versões pré-lançamento vêm **antes** da versão final associada.
      * Exemplo de ordem: `1.0.0-alpha.1` $\to$ `1.0.0-beta` $\to$ `1.0.0-rc.1` $\to$ `1.0.0`.
  * **Uso:** Perfeito para fases de **Alpha** (testes iniciais), **Beta** (testes com funcionalidades completas, mas com bugs esperados) e **RC** (Release Candidate - potencialmente o que será o lançamento final).

### 5\. Metadados de Compilação (Build Metadata)

Para fornecer informações sobre uma compilação específica, você pode adicionar metadados usando um sinal de adição (`+`).

  * **Formato:** Use um sinal de mais (`+`) seguido por identificadores. Exemplo: `1.0.0+20240930.gitsha.f7c3f3`
  * **Importante:** Os metadados de compilação **NÃO** afetam a precedência da versão. Ou seja, `1.0.0+build1` e `1.0.0+build2` são consideradas a **mesma** versão na ordem SemVer, mas são compilações diferentes.

-----

## SemVer e o Controle de Código-Fonte (Git)

A melhor forma de gerenciar o Versionamento Semântico em projetos que usam **Git** é através do uso de **Tags**.

### 1\. Criando Tags

Sempre que você lançar uma nova versão, crie uma **Tag anotada** correspondente no commit exato que representa o lançamento:

```bash
# Exemplo para lançar a versão 1.3.0
git tag -a v1.3.0 -m "Lançamento da nova funcionalidade de busca"
git push origin v1.3.0
```

*Dica: Muitas equipes prefixam a tag com um "v" (e.g., `v1.3.0`) para diferenciá-la de outros identificadores Git, embora o SemVer puro não exija o "v".*

### 2\. Commit Convencional (Conventional Commits)

Considere adotar a especificação **Conventional Commits**. Ela estabelece regras simples para o histórico de *commits* que facilitam a criação de ferramentas automatizadas para determinar o próximo número de versão SemVer.

| Tipo de Commit | Implicação SemVer |
| :--- | :--- |
| `fix:` | Implica um incremento de **PATCH**. Ex: `fix: corrigido problema de login` |
| `feat:` | Implica um incremento de **MENOR**. Ex: `feat: adicionada nova rota de API` |
| `BREAKING CHANGE:` | Implica um incremento de **MAIOR**. Deve ser incluído no corpo ou rodapé do commit. |

Ao usar essa abordagem, ferramentas podem analisar o histórico de commits desde o último *release* e sugerir automaticamente a próxima versão, simplificando o processo de versionamento.
