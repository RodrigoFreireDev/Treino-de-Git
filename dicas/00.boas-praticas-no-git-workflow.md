# O Que São Workflows do Git?

Os **Workflows do Git** (ou fluxos de trabalho do Git) são o **conjunto de regras, convenções e procedimentos** que uma equipe adota para gerenciar, colaborar e entregar código usando o Git de forma consistente e produtiva.

Pense neles como as **"regras de trânsito"** do seu projeto. O Git é uma ferramenta poderosa e flexível, mas sem um workflow definido, a colaboração pode rapidamente virar um caos, com conflitos de merge frequentes e um histórico de código confuso.

---

## Os Pilares de um Workflow do Git

Um workflow bem definido deve responder a perguntas cruciais sobre o desenvolvimento:

* **Onde** o novo trabalho é desenvolvido? (Ex: em um branch separado ou direto no principal?)
* **Como** o código é revisado? (Ex: via **Pull Requests** / **Merge Requests**?)
* **Para onde** o código finalizado vai? (Ex: para o branch `main` ou `develop`?)
* **Como** as correções urgentes (hotfixes) são tratadas?

---

## Principais Tipos de Workflows

Existem vários workflows consagrados. A escolha ideal depende do tamanho da equipe, da frequência de lançamentos e da complexidade do projeto. Os mais comuns são:

### 1. Centralized Workflow (Fluxo Centralizado)

* **Como funciona:** É o mais simples, com apenas um branch principal (`main` ou `master`). Todos os desenvolvedores fazem **commit diretamente nele**.
* **Vantagem:** Simplicidade máxima.
* **Desvantagem:** Não é ideal para trabalho em equipe, pois a chance de **conflitos de merge** e de quebrar o código principal é muito alta.

### 2. Feature Branch Workflow (Branches de Funcionalidades)

* **Como funciona:** O branch principal (`main`) é sempre estável. Para qualquer nova funcionalidade ou correção, um novo **branch de feature** é criado a partir do `main`. O trabalho é desenvolvido, revisado (via Pull Request) e, em seguida, **mesclado** de volta ao `main`.
* **Vantagem:** Mantém o branch principal limpo e garante que as novas funcionalidades sejam isoladas e revisadas antes da integração. É muito popular e serve como base para outros workflows.

### 3. GitHub Flow (Fluxo do GitHub)

* **Como funciona:** É uma versão **simplificada e ágil** do Feature Branch. Ele mantém o branch `main` **sempre implementável (deployable)**. A regra é:
    1.  Crie um branch a partir do `main` para qualquer trabalho.
    2.  Comite no seu branch de feature.
    3.  Abra um **Pull Request** para revisão.
    4.  Após aprovação, **faça o merge** para o `main` e **implante (deploy)** imediatamente.
* **Vantagem:** Extremamente simples, ideal para equipes que fazem **lançamentos contínuos e frequentes (CI/CD)**.

### 4. Gitflow Workflow (Fluxo Gitflow)

* **Como funciona:** O mais **estruturado** e **complexo**. Ele utiliza múltiplos branches de longa duração com funções específicas:
    * **`main`:** Código pronto para produção (releases).
    * **`develop`:** Código de integração para features finalizadas.
    * **`feature/*`:** Branches para novas funcionalidades (criados a partir do `develop`).
    * **`release/*`:** Branches para preparação de um novo lançamento (para testes finais).
    * **`hotfix/*`:** Branches para correções urgentes de bugs em produção (criados a partir do `main`).
* **Vantagem:** Excelente para projetos grandes com **ciclos de lançamento agendados** e que precisam dar suporte a múltiplas versões (ex: software de desktop).
* **Desvantagem:** É complexo e adiciona muita sobrecarga para equipes pequenas ou projetos que utilizam CI/CD.

---

### Conclusão

A escolha de um workflow é uma decisão de equipe crucial para a eficiência e estabilidade do seu projeto. O **Feature Branch** e o **GitHub Flow** são os mais recomendados atualmente para a maioria dos projetos web modernos devido à sua simplicidade e agilidade.

---------------------------------------------------------------------------------------------------

# Fluxos de Trabalho do Git: Gitflow vs. Trunk-Based

O **Gitflow** é um modelo tradicional, estruturado e ideal para lançamentos agendados. O **Trunk-Based Development (TBD)** é um modelo moderno e leve, ideal para integração contínua e lançamentos rápidos.

-----

## 1\. Gitflow Workflow (Fluxo Gitflow)

O Gitflow é definido por seus **vários branches de longa duração** e regras estritas para interação entre eles, garantindo que o branch principal (`main`) seja sempre o código de produção.

### Branches de Longa Duração (Permanentes)

| Branch | Propósito | Regras |
| :--- | :--- | :--- |
| **`main`** (ou `master`) | Contém apenas o **código de produção** (sempre estável). Cada merge neste branch recebe uma tag de versão. | Cria branches de `release` e `hotfix`. |
| **`develop`** | Contém o histórico de desenvolvimento em andamento. É a integração de todas as features concluídas. | Cria branches de `feature`. |

### Branches de Curta Duração (Temporários)

#### 1\. Branch de Feature (`feature/*`)

  * **Passo 1:** Criado a partir de **`develop`**.
    ```bash
    git checkout develop
    git checkout -b feature/nome-da-feature
    ```
  * **Passo 2:** Desenvolvimento e commits locais.
  * **Passo 3:** Concluída a feature, ela é mesclada de volta ao **`develop`** (via Pull Request).
    ```bash
    git checkout develop
    git merge --no-ff feature/nome-da-feature
    git branch -d feature/nome-da-feature
    ```

#### 2\. Branch de Release (`release/*`)

  * **Passo 1:** Criado a partir de **`develop`** quando o código está pronto para ser testado e lançado. A partir daqui, nenhuma nova feature é adicionada, apenas correções de bugs.
    ```bash
    git checkout -b release/v1.2.0 develop
    ```
  * **Passo 2:** Concluída a estabilização (testes, correções finais), é mesclado em **dois branches**:
      * **`main`** (para marcar a nova versão de produção, com tag).
      * **`develop`** (para garantir que as correções da release entrem no próximo ciclo de desenvolvimento).
    <!-- end list -->
    ```bash
    # Mescla para o main e tagueia a versão
    git checkout main
    git merge release/v1.2.0
    git tag -a v1.2.0

    # Mescla de volta para o develop
    git checkout develop
    git merge release/v1.2.0

    # Deleta o branch de release
    git branch -d release/v1.2.0
    ```

#### 3\. Branch de Hotfix (`hotfix/*`)

  * **Passo 1:** Criado a partir de **`main`** para corrigir urgentemente um bug em produção.
    ```bash
    git checkout -b hotfix/bug-critico main
    ```
  * **Passo 2:** Concluída a correção, é mesclado em **dois branches**:
      * **`main`** (para implantação imediata em produção).
      * **`develop`** (para garantir que a correção não seja perdida no próximo ciclo).
    <!-- end list -->
    ```bash
    # Mescla para o main e tagueia a correção
    git checkout main
    git merge hotfix/bug-critico
    git tag -a v1.2.1

    # Mescla de volta para o develop
    git checkout develop
    git merge hotfix/bug-critico

    # Deleta o branch de hotfix
    git branch -d hotfix/bug-critico
    ```

-----

## 2\. Trunk-Based Development (TBD)

O TBD se concentra em ter um único branch principal de longa duração (o "trunk" ou **`main`**) e integrar o trabalho nele **direta e frequentemente** através de **branches de feature de vida muito curta**. É a espinha dorsal da Integração Contínua (CI/CD).

### Princípios Chave

  * **Um Branch Principal:** O **`main`** é o único branch de longa duração e deve estar sempre pronto para ser lançado (deployable).
  * **Branches Curtos:** Branches de feature duram no máximo algumas horas (no máximo 1 ou 2 dias).
  * **Integração Frequente:** Os desenvolvedores fazem merge para o `main` no mínimo uma vez por dia.

### Fluxo Completo

#### 1\. Desenvolvimento da Feature

  * **Passo 1:** O desenvolvedor cria um branch de feature de vida curta a partir do **`main`**.
    ```bash
    git checkout main
    git pull origin main # Garante que você tem a versão mais recente
    git checkout -b feature/pequena-correcao
    ```
  * **Passo 2:** O desenvolvedor trabalha em pequenos pedaços e faz commits frequentes nesse branch.
  * **Passo 3 (Opcional, mas recomendado):** Se o branch de feature durar mais de algumas horas, o desenvolvedor deve **rebasear** o seu branch no `main` regularmente para pegar as atualizações.
    ```bash
    git pull --rebase origin main
    ```

#### 2\. Revisão e Merge

  * **Passo 4:** Quando a feature estiver pronta (em poucas horas), o desenvolvedor abre um **Pull Request** (PR) ou **Merge Request**.
  * **Passo 5:** Após uma revisão rápida e testes automatizados (CI/CD), o branch de feature é mesclado ao **`main`** (geralmente usando a opção **Squash and Merge** ou **Rebase and Merge** para manter o histórico do `main` limpo).
    ```bash
    # O merge é feito via interface (GitHub/GitLab/Bitbucket),
    # mas o comando seria:
    git checkout main
    git merge --squash feature/pequena-correcao
    git commit -m "feat: Adiciona funcionalidade X"
    git push origin main
    git branch -d feature/pequena-correcao
    ```

#### 3\. Lançamentos (Releases) e Hotfixes

  * **Lançamentos (Releases):** Não há um branch de `release`. As implantações são feitas **diretamente a partir do `main`** ou de um **commit tagueado** no `main`.
    ```bash
    # Cria uma tag no commit atual do main que será implantado
    git tag -a v1.2.0 -m "Release v1.2.0"
    ```
  * **Hotfixes:** Não há branch de `hotfix`. As correções são tratadas como qualquer outra feature: criadas em um branch curto a partir do `main` e mescladas de volta imediatamente.

## Resumo Comparativo

| Característica | Gitflow | Trunk-Based Development |
| :--- | :--- | :--- |
| **Complexidade** | Alta (muitas regras e branches) | Baixa (muitas automações e poucos branches) |
| **Branches Longa Duração** | `main` e `develop` | Apenas `main` (o trunk) |
| **Frequência de Merge** | Baixa (features só se juntam no `develop`) | **Alta** (todos mesclam diariamente) |
| **Ideal Para** | Projetos com **lançamentos agendados** (ex: trimestrais) e software que requer suporte a múltiplas versões. | **CI/CD** (Integração e Entrega Contínuas) e equipes que lançam código **várias vezes ao dia**. |
| **Risco de Conflito** | Conflitos de merge grandes, mas menos frequentes. | Conflitos pequenos, mas frequentes (são resolvidos rapidamente). |

-----

Existem outros métodos de fluxo de trabalho Git muito usados na comunidade, e um deles se destaca como o **mais popular** na maioria das equipes modernas de desenvolvimento web: o **GitHub Flow**.

-----

## Os 3 Fluxos de Trabalho Mais Usados Atualmente

A comunidade moderna tende a se afastar da complexidade do Gitflow em favor de modelos mais simples e alinhados com a Integração Contínua/Entrega Contínua (CI/CD). Os três principais são:

| Fluxo de Trabalho | Complexidade | Foco Principal | Melhor para |
| :--- | :--- | :--- | :--- |
| **GitHub Flow** | Baixa | Simplicidade e **Deploy Contínuo**. | Web apps e projetos open source (o mais popular). |
| **Trunk-Based Development** | Baixa | Integração Frequente e **Alta Velocidade**. | Projetos com foco em *Entrega Contínua*. |
| **Gitflow** | Alta | **Lançamentos Agendados** e suporte a múltiplas versões. | Software tradicional e grandes sistemas legados. |

-----

## 1\. GitHub Flow (O Mais Popular)

O **GitHub Flow** é o fluxo de trabalho mais popular e amplamente adotado, especialmente em ambientes que utilizam plataformas como GitHub, GitLab ou Bitbucket e que fazem implantações (deploys) de forma contínua.

É o modelo que você já usa no seu dia a dia quando cria um branch de feature, abre um Pull Request (PR) e o mescla.

### O Fluxo Completo do GitHub Flow

O GitHub Flow é uma variação simplificada do Feature Branch Workflow e se baseia em uma regra fundamental: **o branch `main` é sempre estável e implementável.**

1.  **Crie um Branch:** Qualquer novo trabalho (feature, correção, experimento) começa com um novo branch a partir de `main`. O nome do branch deve ser descritivo (ex: `add-botao-login` ou `fix-erro-api`).
    ```bash
    git checkout main
    git checkout -b nome-do-branch
    ```
2.  **Comite Localmente:** Faça o trabalho e comite no seu branch de feature.
    ```bash
    git commit -m "feat: implementa nova feature"
    ```
3.  **Abra um Pull Request (PR):** Envie seu branch para o repositório remoto e **abra um PR** para o `main`. Este é o **ponto central para feedback, revisão de código e testes automatizados (CI)**.
4.  **Revisão e Teste:** Outros membros da equipe revisam o código e os testes de CI/CD são executados. Se houver problemas, o código é corrigido e o branch é atualizado.
5.  **Merge e Deploy:** Após a aprovação e a conclusão dos testes, o PR é **mesclado no `main`**. A mesclagem no `main` geralmente aciona o **deploy automático** (entrega contínua).
6.  **Deletar o Branch:** O branch de feature é deletado, e o ciclo se repete.

### Por que é o Mais Popular?

  * **Simplicidade:** Não exige múltiplos branches de longa duração (`develop`, `release`), o que reduz a sobrecarga e o risco de desvio de código.
  * **Agilidade:** Alinha-se perfeitamente com a **Entrega Contínua (Continuous Delivery)**, pois cada merge no `main` significa que o código está pronto para ir (ou já foi) para produção.

-----

## 2\. Forking Workflow

Este método não é usado principalmente em equipes internas, mas é o padrão de trabalho para projetos de **Código Aberto (Open Source)**.

### O Fluxo Completo do Forking Workflow

Neste modelo, os colaboradores não têm acesso direto de *push* (envio de código) ao repositório central (`upstream`).

1.  **Fork:** Um colaborador faz um **"fork"** (cópia) do repositório central para sua própria conta.
2.  **Clone:** O colaborador clona o **seu fork** localmente.
3.  **Crie um Branch:** O trabalho é feito em um branch de feature local no seu fork.
4.  **Push para o Fork:** O colaborador envia o branch para o **seu próprio fork remoto**.
5.  **Pull Request:** O colaborador abre um Pull Request do seu fork para o branch `main` do **repositório central original**.
6.  **Revisão e Merge:** O mantenedor do projeto central revisa o PR e decide fazer o merge, rejeitar ou pedir mudanças.

Este fluxo é essencial para projetos grandes e públicos onde qualquer pessoa pode contribuir sem receber permissões de escrita no repositório principal.

-----

Em resumo, se você busca o padrão mais moderno e adotado para desenvolvimento ágil em equipe, a resposta é o **GitHub Flow**. Ele oferece a combinação ideal de segurança (graças ao PR/revisão) e velocidade (graças à eliminação de branches complexos).
